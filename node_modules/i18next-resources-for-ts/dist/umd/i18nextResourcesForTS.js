(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
  typeof define === 'function' && define.amd ? define(['exports'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.i18nextResourcesForTS = {}));
})(this, (function (exports) { 'use strict';

  const defaults = {
    quotes: 'single'
  };

  function trim(arr, startOnly) {
    let start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }
    let end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }
    if (start > end) return [];
    if (startOnly) return arr.slice(start);
    return arr.slice(start, end);
  }
  const pathSeparatorWin = '\\';
  const pathSeparator = '/';
  function relative(from, to) {
    let separatorInFileContent = pathSeparator;
    let separator = pathSeparator;
    const seemsWindowsPath = from.indexOf(pathSeparatorWin) > -1 || to.indexOf(pathSeparatorWin) > -1;
    if (seemsWindowsPath) {
      separator = pathSeparatorWin;
    }
    if (from.endsWith(separator)) from = from.substring(0, from.length - separator.length);
    const toParts = trim(to.split(separator), true);
    const splittedFrom = from.split(separator);
    const lowerFromParts = trim(splittedFrom, from.indexOf('.') < 0);
    const splittedTo = to.split(separator);
    const lowerToParts = trim(splittedTo, true);
    const length = Math.min(lowerFromParts.length, lowerToParts.length);
    let samePartsLength = length;
    for (let i = 0; i < length; i++) {
      if (lowerFromParts[i] !== lowerToParts[i]) {
        samePartsLength = i;
        break;
      }
    }
    if (samePartsLength === 0) return to;
    let outputParts = [];
    for (let i = samePartsLength; i < lowerFromParts.length; i++) {
      outputParts.push('..');
    }
    outputParts = outputParts.concat(toParts.slice(samePartsLength));
    if (seemsWindowsPath && outputParts[2] === ':') {
      separatorInFileContent = pathSeparatorWin;
    }
    let ret = outputParts.join(separatorInFileContent);
    if (!ret.startsWith(from.substring(0, 2)) && !ret.startsWith('.')) {
      ret = `.${separatorInFileContent}${ret}`;
    }
    return ret;
  }

  function getVarName(name) {
    if (name.indexOf('-') > 0 || name.indexOf(' ') > 0) {
      return name.replace(/[- ]/g, '');
    }
    return name;
  }
  function tocForResources(namespaces, toPath) {
    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
    const opt = {
      ...options,
      ...defaults
    };
    const quoteChar = opt.quotes === 'single' ? '\'' : '"';
    let toc = '';
    namespaces.forEach(ns => {
      const nameToUse = getVarName(ns.name);
      if (ns.tsPath) {
        toc += `import ${nameToUse} from ${quoteChar}${relative(toPath, ns.tsPath.replace('.ts', ''))}${quoteChar};\n`;
      } else {
        toc += `import ${nameToUse} from ${quoteChar}${relative(toPath, ns.path)}${quoteChar};\n`;
      }
    });
    toc += '\nconst resources = {';
    namespaces.forEach((ns, i) => {
      const nameToUse = getVarName(ns.name);
      if (nameToUse !== ns.name) {
        toc += `\n  ${quoteChar}${ns.name}${quoteChar}: ${nameToUse}`;
      } else {
        toc += `\n  ${ns.name}`;
      }
      if (i < namespaces.length - 1) {
        toc += ',';
      }
    });
    toc += '\n} as const;\n';
    toc += '\nexport default resources;\n';
    return toc;
  }

  function mergeResources(namespaces) {
    return namespaces.reduce((prev, cur) => {
      prev[cur.name] = cur.resources;
      return prev;
    }, {});
  }

  function mergeResourcesAsInterface(namespaces) {
    const resources = mergeResources(namespaces);
    let interfaceFileContent = 'interface Resources ';
    interfaceFileContent += JSON.stringify(resources, null, 2);
    interfaceFileContent += '\n\nexport default Resources;\n';
    return interfaceFileContent;
  }

  function json2ts(resources) {
    let tsContent = 'const ns = ';
    tsContent += JSON.stringify(resources, null, 2);
    tsContent += ' as const;\n';
    tsContent += '\nexport default ns;\n';
    return tsContent;
  }

  exports.json2ts = json2ts;
  exports.mergeResources = mergeResources;
  exports.mergeResourcesAsInterface = mergeResourcesAsInterface;
  exports.tocForResources = tocForResources;

}));
