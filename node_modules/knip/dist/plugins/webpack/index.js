import { compact } from '#p/util/array.js';
import { isInternal, join, relative } from '#p/util/path.js';
import { hasDependency } from '#p/util/plugin.js';
import { toEntryPattern, toProductionEntryPattern } from '#p/util/protocols.js';
import { getDependenciesFromConfig } from '../babel/index.js';
const title = 'Webpack';
const enablers = ['webpack', 'webpack-cli'];
const isEnabled = ({ dependencies }) => hasDependency(dependencies, enablers);
const config = ['webpack.config*.{js,ts,mjs,cjs,mts,cts}'];
const production = [];
const hasBabelOptions = (use) => Boolean(use) &&
    typeof use !== 'string' &&
    'loader' in use &&
    typeof use.loader === 'string' &&
    use.loader === 'babel-loader' &&
    typeof use.options === 'object';
const info = { compiler: '', issuer: '', realResource: '', resource: '', resourceQuery: '' };
const resolveRuleSetDependencies = (rule) => {
    if (!rule || typeof rule === 'string')
        return [];
    if (typeof rule.use === 'string')
        return [rule.use];
    let useItem = rule.use ?? rule.loader ?? rule;
    if (typeof useItem === 'function')
        useItem = useItem(info);
    if (typeof useItem === 'string' && hasBabelOptions(rule)) {
        return [useItem, ...getDependenciesFromConfig(rule.options)];
    }
    return [useItem].flat().flatMap((item) => {
        if (!item)
            return [];
        if (hasBabelOptions(item)) {
            return [...resolveUseItem(item), ...getDependenciesFromConfig(item.options)];
        }
        return resolveUseItem(item);
    });
};
const resolveUseItem = (use) => {
    if (!use)
        return [];
    if (typeof use === 'string')
        return [use];
    if ('loader' in use && typeof use.loader === 'string')
        return [use.loader];
    return [];
};
export const findWebpackDependenciesFromConfig = async ({ config, cwd }) => {
    const passes = typeof config === 'function' ? [false, true] : [false];
    const dependencies = new Set();
    const entryPatterns = new Set();
    for (const isProduction of passes) {
        const env = { production: isProduction };
        const argv = { mode: isProduction ? 'production' : 'development' };
        const resolvedConfig = typeof config === 'function' ? await config(env, argv) : config;
        for (const options of [resolvedConfig].flat()) {
            const entries = [];
            for (const loader of options.module?.rules?.flatMap(resolveRuleSetDependencies) ?? []) {
                dependencies.add(loader.replace(/\?.*/, ''));
            }
            if (typeof options.entry === 'string')
                entries.push(options.entry);
            else if (Array.isArray(options.entry))
                entries.push(...options.entry);
            else if (typeof options.entry === 'object') {
                for (const entry of Object.values(options.entry)) {
                    if (typeof entry === 'string')
                        entries.push(entry);
                    else if (Array.isArray(entry))
                        entries.push(...entry);
                    else if (typeof entry === 'function')
                        entries.push(entry());
                    else if (entry && typeof entry === 'object' && 'filename' in entry)
                        entries.push(entry['filename']);
                }
            }
            for (const entry of entries) {
                if (!isInternal(entry)) {
                    dependencies.add(entry);
                }
                else {
                    const item = relative(cwd, join(options.context ? options.context : cwd, entry));
                    const value = options.mode === 'development' ? toEntryPattern(item) : toProductionEntryPattern(item);
                    entryPatterns.add(value);
                }
            }
        }
    }
    return { dependencies, entryPatterns };
};
const resolveConfig = async (localConfig, options) => {
    const { cwd, isProduction, manifest } = options;
    const { entryPatterns, dependencies } = await findWebpackDependenciesFromConfig({ config: localConfig, cwd });
    if (isProduction)
        return [...entryPatterns];
    const scripts = Object.values(manifest.scripts ?? {});
    const webpackCLI = scripts.some(script => script && /(?<=^|\s)webpack(?=\s|$)/.test(script)) ? ['webpack-cli'] : [];
    const webpackDevServer = scripts.some(script => script?.includes('webpack serve')) ? ['webpack-dev-server'] : [];
    return compact([...entryPatterns, ...dependencies, ...webpackCLI, ...webpackDevServer]);
};
export default {
    title,
    enablers,
    isEnabled,
    config,
    production,
    resolveConfig,
};
