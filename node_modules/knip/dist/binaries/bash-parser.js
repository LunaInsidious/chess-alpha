import parse from '@ericcornelissen/bash-parser';
import { debugLogObject } from '../util/debug.js';
import * as FallbackResolver from './resolvers/fallback.js';
import KnownResolvers from './resolvers/index.js';
import { stripBinaryPath } from './util.js';
export const getBinariesFromScript = (script, options) => {
    if (!script)
        return [];
    const fromArgs = (args) => getBinariesFromScript(args.filter(arg => arg !== '--').join(' '), { ...options, knownGlobalsOnly: false });
    const getBinariesFromNodes = (nodes) => nodes.flatMap(node => {
        switch (node.type) {
            case 'Command': {
                const binary = node.name?.text ? stripBinaryPath(node.name.text) : node.name?.text;
                const commandExpansions = node.prefix?.flatMap(prefix => prefix.expansion?.filter(expansion => expansion.type === 'CommandExpansion') ?? []) ?? [];
                if (commandExpansions.length > 0) {
                    return commandExpansions.flatMap(expansion => getBinariesFromNodes(expansion.commandAST.commands)) ?? [];
                }
                if (!binary || binary === '.' || binary === 'source' || binary === '[')
                    return [];
                if (binary.startsWith('-') || binary.startsWith('"') || binary.startsWith('..'))
                    return [];
                if (['deno'].includes(binary))
                    return [];
                const args = node.suffix?.map(arg => arg.text) ?? [];
                if (['!', 'test'].includes(binary))
                    return fromArgs(args);
                if (binary in KnownResolvers) {
                    const resolver = KnownResolvers[binary];
                    return resolver(binary, args, { ...options, fromArgs });
                }
                if (options.knownGlobalsOnly)
                    return [];
                return FallbackResolver.resolve(binary, args, { ...options, fromArgs });
            }
            case 'LogicalExpression':
                return getBinariesFromNodes([node.left, node.right]);
            case 'If':
                return getBinariesFromNodes([node.clause, node.then, ...(node.else ? [node.else] : [])]);
            case 'For':
                return getBinariesFromNodes(node.do.commands);
            case 'CompoundList':
                return getBinariesFromNodes(node.commands);
            case 'Pipeline':
                return getBinariesFromNodes(node.commands);
            case 'Function':
                return getBinariesFromNodes(node.body.commands);
            default:
                return [];
        }
    });
    try {
        const parsed = parse(script);
        return parsed?.commands ? getBinariesFromNodes(parsed.commands) : [];
    }
    catch (error) {
        debugLogObject('*', 'Bash parser error', error);
        return [];
    }
};
