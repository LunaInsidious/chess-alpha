import ts from 'typescript';
import { CacheConsultant } from './CacheConsultant.js';
import { getCompilerExtensions } from './compilers/index.js';
import { DEFAULT_EXTENSIONS, FOREIGN_FILE_EXTENSIONS } from './constants.js';
import { createHosts } from './typescript/createHosts.js';
import { _getImportsAndExports } from './typescript/getImportsAndExports.js';
import { timerify } from './util/Performance.js';
import { compact } from './util/array.js';
import { isStartsLikePackageName, sanitizeSpecifier } from './util/modules.js';
import { dirname, extname, isInNodeModules, join } from './util/path.js';
import { deserialize, serialize } from './util/serialize.js';
const baseCompilerOptions = {
    allowJs: true,
    allowSyntheticDefaultImports: true,
    declaration: false,
    declarationMap: false,
    esModuleInterop: true,
    inlineSourceMap: false,
    inlineSources: false,
    jsx: ts.JsxEmit.Preserve,
    jsxImportSource: undefined,
    lib: [],
    types: ['node'],
    noEmit: true,
    skipDefaultLibCheck: true,
    skipLibCheck: true,
    sourceMap: false,
};
const tsCreateProgram = timerify(ts.createProgram);
export class ProjectPrincipal {
    entryPaths = new Set();
    projectPaths = new Set();
    referencedDependencies = new Set();
    skipExportsAnalysis = new Set();
    isGitIgnored;
    cwd;
    compilerOptions;
    extensions;
    syncCompilers;
    asyncCompilers;
    isSkipLibs;
    isWatch;
    cache;
    backend;
    findReferences;
    constructor({ compilerOptions, cwd, compilers, isGitIgnored, isSkipLibs, isWatch }, n) {
        this.cwd = cwd;
        this.isGitIgnored = isGitIgnored;
        this.compilerOptions = {
            ...compilerOptions,
            ...baseCompilerOptions,
            types: compact([...(compilerOptions.types ?? []), ...baseCompilerOptions.types]),
            allowNonTsExtensions: true,
        };
        const [syncCompilers, asyncCompilers] = compilers;
        this.extensions = new Set([...DEFAULT_EXTENSIONS, ...getCompilerExtensions(compilers)]);
        this.syncCompilers = syncCompilers;
        this.asyncCompilers = asyncCompilers;
        this.isSkipLibs = isSkipLibs;
        this.isWatch = isWatch;
        this.cache = new CacheConsultant(`project-${n}`);
    }
    init() {
        const { fileManager, compilerHost, resolveModuleNames, languageServiceHost } = createHosts({
            cwd: this.cwd,
            compilerOptions: this.compilerOptions,
            entryPaths: this.entryPaths,
            compilers: [this.syncCompilers, this.asyncCompilers],
            isSkipLibs: this.isSkipLibs,
            useResolverCache: !this.isWatch,
        });
        this.backend = {
            fileManager,
            compilerHost,
            resolveModuleNames,
            languageServiceHost,
        };
    }
    addPaths(paths) {
        this.compilerOptions.paths = { ...this.compilerOptions.paths, ...paths };
    }
    addCompilers(compilers) {
        this.syncCompilers = new Map([...this.syncCompilers, ...compilers[0]]);
        this.asyncCompilers = new Map([...this.asyncCompilers, ...compilers[1]]);
        this.extensions = new Set([...this.extensions, ...getCompilerExtensions(compilers)]);
    }
    createProgram() {
        this.backend.program = tsCreateProgram(Array.from(this.entryPaths), this.compilerOptions, this.backend.compilerHost, this.backend.program);
        const typeChecker = timerify(this.backend.program.getTypeChecker);
        this.backend.typeChecker = typeChecker();
    }
    hasAcceptedExtension(filePath) {
        return this.extensions.has(extname(filePath));
    }
    addEntryPath(filePath, options) {
        if (!isInNodeModules(filePath) && this.hasAcceptedExtension(filePath)) {
            this.entryPaths.add(filePath);
            this.projectPaths.add(filePath);
            if (options?.skipExportsAnalysis)
                this.skipExportsAnalysis.add(filePath);
        }
    }
    addEntryPaths(filePaths, options) {
        for (const filePath of filePaths)
            this.addEntryPath(filePath, options);
    }
    addProjectPath(filePath) {
        if (!isInNodeModules(filePath) && this.hasAcceptedExtension(filePath)) {
            this.projectPaths.add(filePath);
            this.deletedFiles.delete(filePath);
        }
    }
    deletedFiles = new Set();
    removeProjectPath(filePath) {
        this.entryPaths.delete(filePath);
        this.projectPaths.delete(filePath);
        this.invalidateFile(filePath);
        this.deletedFiles.add(filePath);
    }
    addReferencedDependencies(workspaceName, referencedDependencies) {
        for (const referencedDependency of referencedDependencies)
            this.referencedDependencies.add([...referencedDependency, workspaceName]);
    }
    async runAsyncCompilers() {
        const add = timerify(this.backend.fileManager.compileAndAddSourceFile.bind(this.backend.fileManager));
        const extensions = Array.from(this.asyncCompilers.keys());
        const files = Array.from(this.projectPaths).filter(filePath => extensions.includes(extname(filePath)));
        for (const filePath of files) {
            await add(filePath);
        }
    }
    getUsedResolvedFiles() {
        this.createProgram();
        const sourceFiles = this.getProgramSourceFiles();
        return Array.from(this.projectPaths).filter(filePath => sourceFiles.has(filePath));
    }
    getProgramSourceFiles() {
        const programSourceFiles = this.backend.program?.getSourceFiles().map(sourceFile => sourceFile.fileName);
        return new Set(programSourceFiles);
    }
    getUnreferencedFiles() {
        const sourceFiles = this.getProgramSourceFiles();
        return Array.from(this.projectPaths).filter(filePath => !sourceFiles.has(filePath));
    }
    getResolvedModuleHandler(sourceFile) {
        const getResolvedModule = this.backend.program?.getResolvedModule;
        const resolver = getResolvedModule
            ? (specifier) => getResolvedModule(sourceFile, specifier, undefined)
            : (specifier) => sourceFile.resolvedModules?.get(specifier, undefined);
        if (!this.isWatch)
            return resolver;
        return (specifier) => {
            const m = resolver(specifier);
            if (m?.resolvedModule?.resolvedFileName && this.deletedFiles.has(m.resolvedModule.resolvedFileName))
                return;
            return m;
        };
    }
    analyzeSourceFile(filePath, options) {
        const fd = this.cache.getFileDescriptor(filePath);
        if (!fd.changed && fd.meta?.data)
            return deserialize(fd.meta.data);
        if (!this.backend.typeChecker)
            throw new Error('Must initialize TypeChecker before source file analysis');
        const sourceFile = this.backend.fileManager.getSourceFile(filePath);
        if (!sourceFile)
            throw new Error(`Unable to find ${filePath}`);
        const skipExports = this.skipExportsAnalysis.has(filePath);
        const { imports, exports, scripts } = _getImportsAndExports(sourceFile, this.getResolvedModuleHandler(sourceFile), this.backend.typeChecker, { ...options, skipExports });
        const { internal, unresolved, external } = imports;
        const unresolvedImports = new Set();
        for (const unresolvedImport of unresolved) {
            const { specifier } = unresolvedImport;
            if (specifier.startsWith('http')) {
                continue;
            }
            const resolvedModule = this.resolveModule(specifier, filePath);
            if (resolvedModule) {
                if (resolvedModule.isExternalLibraryImport) {
                    const sanitizedSpecifier = sanitizeSpecifier(specifier);
                    external.add(sanitizedSpecifier);
                }
                else {
                    const isIgnored = this.isGitIgnored(resolvedModule.resolvedFileName);
                    if (!isIgnored)
                        this.addEntryPath(resolvedModule.resolvedFileName, { skipExportsAnalysis: true });
                }
            }
            else {
                const sanitizedSpecifier = sanitizeSpecifier(specifier);
                if (isStartsLikePackageName(sanitizedSpecifier)) {
                    external.add(sanitizedSpecifier);
                }
                else {
                    const isIgnored = this.isGitIgnored(join(dirname(filePath), sanitizedSpecifier));
                    if (!isIgnored) {
                        const ext = extname(sanitizedSpecifier);
                        const hasIgnoredExtension = FOREIGN_FILE_EXTENSIONS.has(ext);
                        if (!ext || (ext !== '.json' && !hasIgnoredExtension)) {
                            unresolvedImports.add(unresolvedImport);
                        }
                    }
                }
            }
        }
        return {
            imports: {
                internal,
                unresolved: unresolvedImports,
                external,
            },
            exports,
            scripts,
        };
    }
    invalidateFile(filePath) {
        this.backend.fileManager.snapshotCache.delete(filePath);
        this.backend.fileManager.sourceFileCache.delete(filePath);
    }
    resolveModule(specifier, filePath = specifier) {
        return this.backend.resolveModuleNames([specifier], filePath)[0];
    }
    findUnusedMembers(filePath, members) {
        if (!this.findReferences) {
            const languageService = ts.createLanguageService(this.backend.languageServiceHost, ts.createDocumentRegistry());
            this.findReferences = timerify(languageService.findReferences);
        }
        return members.filter(member => {
            if (member.jsDocTags.has('@public'))
                return false;
            const referencedSymbols = this.findReferences?.(filePath, member.pos);
            const files = (referencedSymbols ?? [])
                .flatMap(refs => refs.references)
                .filter(ref => !ref.isDefinition)
                .map(ref => ref.fileName);
            const internalRefs = files.filter(f => f === filePath);
            const externalRefs = files.filter(f => f !== filePath);
            return externalRefs.length === 0 && internalRefs.length === 0;
        });
    }
    hasReferences(filePath, exportedItem) {
        if (exportedItem.jsDocTags.has('@public'))
            return false;
        if (!this.findReferences) {
            const languageService = ts.createLanguageService(this.backend.languageServiceHost, ts.createDocumentRegistry());
            this.findReferences = timerify(languageService.findReferences);
        }
        const referencedSymbols = this.findReferences?.(filePath, exportedItem.pos);
        const files = (referencedSymbols ?? [])
            .flatMap(refs => refs.references)
            .filter(ref => !ref.isDefinition)
            .map(ref => ref.fileName);
        const externalRefs = files.filter(f => f !== filePath);
        return externalRefs.length > 0;
    }
    reconcileCache(serializableMap) {
        for (const filePath in serializableMap) {
            const fd = this.cache.getFileDescriptor(filePath);
            if (!fd?.meta)
                continue;
            fd.meta.data = serialize(serializableMap[filePath]);
        }
        this.cache.reconcile();
    }
}
