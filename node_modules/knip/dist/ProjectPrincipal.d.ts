import ts from 'typescript';
import { CacheConsultant } from './CacheConsultant.js';
import type { PrincipalOptions } from './PrincipalFactory.js';
import type { ReferencedDependencies } from './WorkspaceWorker.js';
import type { AsyncCompilers, SyncCompilers } from './compilers/types.js';
import type { SerializableExport, SerializableExportMember, SerializableFile, SerializableMap } from './types/serializable-map.js';
import type { ProgramMaybe53 } from './typescript/SourceFile.js';
import type { SourceFileManager } from './typescript/SourceFileManager.js';
import { type GetImportsAndExportsOptions } from './typescript/getImportsAndExports.js';
import type { createCustomModuleResolver } from './typescript/resolveModuleNames.js';
export declare class ProjectPrincipal {
    entryPaths: Set<string>;
    projectPaths: Set<string>;
    referencedDependencies: Set<[string, string, string]>;
    skipExportsAnalysis: Set<string>;
    isGitIgnored: (path: string) => boolean;
    cwd: string;
    compilerOptions: ts.CompilerOptions;
    extensions: Set<string>;
    syncCompilers: SyncCompilers;
    asyncCompilers: AsyncCompilers;
    isSkipLibs: boolean;
    isWatch: boolean;
    cache: CacheConsultant<SerializableFile>;
    backend: {
        fileManager: SourceFileManager;
        compilerHost: ts.CompilerHost;
        resolveModuleNames: ReturnType<typeof createCustomModuleResolver>;
        program?: ProgramMaybe53;
        typeChecker?: ts.TypeChecker;
        languageServiceHost: ts.LanguageServiceHost;
    };
    findReferences?: ts.LanguageService['findReferences'];
    constructor({ compilerOptions, cwd, compilers, isGitIgnored, isSkipLibs, isWatch }: PrincipalOptions, n: number);
    init(): void;
    addPaths(paths: ts.CompilerOptions['paths']): void;
    addCompilers(compilers: [SyncCompilers, AsyncCompilers]): void;
    private createProgram;
    private hasAcceptedExtension;
    addEntryPath(filePath: string, options?: {
        skipExportsAnalysis: boolean;
    }): void;
    addEntryPaths(filePaths: Set<string> | string[], options?: {
        skipExportsAnalysis: boolean;
    }): void;
    addProjectPath(filePath: string): void;
    deletedFiles: Set<unknown>;
    removeProjectPath(filePath: string): void;
    addReferencedDependencies(workspaceName: string, referencedDependencies: ReferencedDependencies): void;
    runAsyncCompilers(): Promise<void>;
    getUsedResolvedFiles(): string[];
    private getProgramSourceFiles;
    getUnreferencedFiles(): string[];
    private getResolvedModuleHandler;
    analyzeSourceFile(filePath: string, options: Omit<GetImportsAndExportsOptions, 'skipExports'>): SerializableFile;
    invalidateFile(filePath: string): void;
    resolveModule(specifier: string, filePath?: string): ts.ResolvedModuleFull | undefined;
    findUnusedMembers(filePath: string, members: SerializableExportMember[]): SerializableExportMember[];
    hasReferences(filePath: string, exportedItem: SerializableExport): boolean;
    reconcileCache(serializableMap: SerializableMap): void;
}
