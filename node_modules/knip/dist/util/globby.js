import * as fs from 'node:fs';
import { promisify } from 'node:util';
import { walk as _walk } from '@nodelib/fs.walk';
import fastGlob from 'fast-glob';
import picomatch from 'picomatch';
import { GLOBAL_IGNORE_PATTERNS, ROOT_WORKSPACE_NAME } from '../constants.js';
import { timerify } from './Performance.js';
import { debugLogObject } from './debug.js';
import { dirname, join, relative, toPosix } from './path.js';
const walk = promisify(_walk);
const _picomatch = timerify(picomatch);
const cachedIgnores = new Map();
function convertGitignoreToPicomatch(pattern) {
    const negated = pattern[0] === '!';
    if (negated) {
        pattern = pattern.slice(1);
    }
    let extPattern;
    if (pattern.startsWith('*/**/'))
        pattern = pattern.slice(5);
    if (pattern.startsWith('/'))
        pattern = pattern.slice(1);
    else if (!pattern.startsWith('**/'))
        pattern = `**/${pattern}`;
    if (pattern.endsWith('/*'))
        extPattern = pattern;
    else if (pattern.endsWith('/'))
        extPattern = `${pattern}**`;
    else
        extPattern = `${pattern}/**`;
    return { negated, patterns: [pattern, extPattern] };
}
function parseGitignoreFile(filePath) {
    const file = fs.readFileSync(filePath, 'utf8');
    return file
        .split(/\r?\n/)
        .filter(line => line.trim() && !line.startsWith('#'))
        .map(pattern => convertGitignoreToPicomatch(pattern.replace(/(?<!\\)#.*/, '').trim()));
}
async function parseFindGitignores(options) {
    const ignores = ['.git', ...GLOBAL_IGNORE_PATTERNS];
    const unignores = [];
    const gitignoreFiles = [];
    const pmOptions = { ignore: unignores };
    const matchers = ignores.map(ignore => _picomatch(ignore, pmOptions));
    const matcher = (str) => {
        for (const isMatch of matchers) {
            const state = isMatch(str);
            if (state)
                return state;
        }
        return false;
    };
    const entryFilter = (entry) => {
        if (entry.dirent.isFile() && entry.name === '.gitignore') {
            gitignoreFiles.push(entry.path);
            const dir = dirname(toPosix(entry.path));
            const base = relative(options.cwd, dir);
            const dirIgnores = base === '' ? ['.git', ...GLOBAL_IGNORE_PATTERNS] : [];
            const dirUnignores = [];
            for (const rule of parseGitignoreFile(entry.path)) {
                const [p, ext] = rule.patterns;
                if (rule.negated) {
                    if (base === '') {
                        if (!unignores.includes(ext))
                            dirUnignores.push(...rule.patterns);
                    }
                    else {
                        if (!unignores.includes(ext.startsWith('**/') ? ext : `**/${ext}`)) {
                            dirUnignores.push(join(base, p), join(base, ext));
                        }
                    }
                }
                else {
                    if (base === '') {
                        if (!ignores.includes(ext))
                            dirIgnores.push(...rule.patterns);
                    }
                    else {
                        if (!ignores.includes(ext.startsWith('**/') ? ext : `**/${ext}`)) {
                            dirIgnores.push(join(base, p), join(base, ext));
                        }
                    }
                }
            }
            ignores.push(...dirIgnores);
            unignores.push(...dirUnignores);
            cachedIgnores.set(dir, { ignores: dirIgnores, unignores: dirUnignores });
            matchers.push(...dirIgnores.map(ignore => _picomatch(ignore, pmOptions)));
            return true;
        }
        return false;
    };
    const deepFilter = (entry) => !matcher(relative(options.cwd, entry.path));
    await walk(options.cwd, {
        entryFilter: timerify(entryFilter),
        deepFilter: timerify(deepFilter),
    });
    debugLogObject('*', 'Parsed gitignore files', { gitignoreFiles, ignores, unignores });
    return { ignores, unignores };
}
const _parseFindGitignores = timerify(parseFindGitignores);
export async function globby(patterns, options) {
    if (Array.isArray(patterns) && patterns.length === 0)
        return [];
    const ignore = options.gitignore && Array.isArray(options.ignore) ? [...options.ignore] : [];
    if (options.gitignore) {
        let dir = options.dir;
        while (dir !== options.cwd) {
            const i = cachedIgnores.get(dir);
            if (i) {
                ignore.push(...i.ignores);
                ignore.push(...i.unignores.map(e => `!${e}`));
            }
            dir = dirname(dir);
        }
        const i = cachedIgnores.get(options.cwd);
        if (i)
            ignore.push(...i.ignores);
    }
    const { dir, ...fastGlobOptions } = { ...options, ignore };
    debugLogObject(relative(options.cwd, dir) || ROOT_WORKSPACE_NAME, 'Glob options', { patterns, ...options });
    return fastGlob(patterns, fastGlobOptions);
}
export async function getGitIgnoredFn(options) {
    cachedIgnores.clear();
    if (options.gitignore === false)
        return () => false;
    const gitignore = await _parseFindGitignores(options);
    const matcher = _picomatch(gitignore.ignores, { ignore: gitignore.unignores });
    const isGitIgnored = (filePath) => {
        const ret = matcher(relative(options.cwd, filePath));
        return ret;
    };
    return timerify(isGitIgnored);
}
