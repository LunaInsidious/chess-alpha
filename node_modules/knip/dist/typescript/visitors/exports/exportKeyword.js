import ts from 'typescript';
import { SymbolType } from '../../../types/issues.js';
import { compact } from '../../../util/array.js';
import { isGetOrSetAccessorDeclaration, isPrivateMember, stripQuotes } from '../../ast-helpers.js';
import { exportVisitor as visit } from '../index.js';
export default visit(() => true, (node, { isFixExports, isFixTypes, isReportClassMembers }) => {
    const exportKeyword = node.modifiers?.find(mod => mod.kind === ts.SyntaxKind.ExportKeyword);
    if (exportKeyword) {
        if (ts.isVariableStatement(node)) {
            return node.declarationList.declarations.flatMap(declaration => {
                if (ts.isObjectBindingPattern(declaration.name)) {
                    return compact(declaration.name.elements.map(element => {
                        if (ts.isIdentifier(element.name)) {
                            const fix = isFixExports ? [element.getStart(), element.getEnd()] : undefined;
                            return {
                                node: element,
                                identifier: element.name.escapedText.toString(),
                                type: SymbolType.UNKNOWN,
                                pos: element.name.getStart(),
                                fix,
                            };
                        }
                    }));
                }
                if (ts.isArrayBindingPattern(declaration.name)) {
                    return compact(declaration.name.elements.map(element => {
                        if (ts.isBindingElement(element)) {
                            const fix = isFixExports ? [element.getStart(), element.getEnd()] : undefined;
                            return {
                                node: element,
                                identifier: element.getText(),
                                type: SymbolType.UNKNOWN,
                                pos: element.getStart(),
                                fix,
                            };
                        }
                    }));
                }
                const identifier = declaration.name.getText();
                const fix = isFixExports ? [exportKeyword.getStart(), exportKeyword.getEnd() + 1] : undefined;
                return {
                    node: declaration,
                    identifier,
                    type: SymbolType.UNKNOWN,
                    pos: declaration.name.getStart(),
                    fix,
                };
            });
        }
        const defaultKeyword = node.modifiers?.find(mod => mod.kind === ts.SyntaxKind.DefaultKeyword);
        if (ts.isFunctionDeclaration(node) && node.name) {
            const identifier = defaultKeyword ? 'default' : node.name.getText();
            const pos = (node.name ?? node.body ?? node).getStart();
            const fix = isFixExports
                ? [exportKeyword.getStart(), (defaultKeyword ?? exportKeyword).getEnd() + 1]
                : undefined;
            return {
                node,
                identifier,
                pos,
                type: SymbolType.FUNCTION,
                fix,
            };
        }
        if (ts.isClassDeclaration(node) && node.name) {
            const identifier = defaultKeyword ? 'default' : node.name.getText();
            const pos = (node.name ?? node).getStart();
            const members = isReportClassMembers
                ? node.members
                    .filter((member) => (ts.isPropertyDeclaration(member) ||
                    ts.isMethodDeclaration(member) ||
                    isGetOrSetAccessorDeclaration(member)) &&
                    !isPrivateMember(member))
                    .map(member => ({
                    node: member,
                    identifier: member.name.getText(),
                    pos: member.name.getStart() + (ts.isComputedPropertyName(member.name) ? 1 : 0),
                    type: SymbolType.MEMBER,
                    fix: undefined,
                }))
                : [];
            const fix = isFixExports
                ? [exportKeyword.getStart(), (defaultKeyword ?? exportKeyword).getEnd() + 1]
                : undefined;
            return {
                node,
                identifier,
                type: SymbolType.CLASS,
                pos,
                members,
                fix,
            };
        }
        if (ts.isTypeAliasDeclaration(node)) {
            const identifier = defaultKeyword ? 'default' : node.name.getText();
            const fix = isFixTypes ? [exportKeyword.getStart(), exportKeyword.getEnd() + 1] : undefined;
            return {
                node,
                identifier,
                type: SymbolType.TYPE,
                pos: node.name.getStart(),
                fix,
            };
        }
        if (ts.isInterfaceDeclaration(node)) {
            const identifier = defaultKeyword ? 'default' : node.name.getText();
            const fix = isFixTypes ? [exportKeyword.getStart(), exportKeyword.getEnd() + 1] : undefined;
            return {
                node,
                identifier,
                type: SymbolType.INTERFACE,
                pos: node.name.getStart(),
                fix,
            };
        }
        if (ts.isEnumDeclaration(node)) {
            const identifier = defaultKeyword ? 'default' : node.name.getText();
            const pos = node.name.getStart();
            const members = node.members.map(member => ({
                node: member,
                identifier: stripQuotes(member.name.getText()),
                pos: member.name.getStart(),
                type: SymbolType.MEMBER,
                fix: undefined,
            }));
            const fix = isFixTypes ? [exportKeyword.getStart(), exportKeyword.getEnd() + 1] : undefined;
            return {
                node,
                identifier,
                type: SymbolType.ENUM,
                pos,
                members,
                fix,
            };
        }
    }
});
